[
    {
        "question": "How do you implement a binary search tree BST in Java?",
        "answer": "Certainly! I\u2019ll present a structured response as if you were in an interview setting.\n\n---\n\n**Interviewer:** Can you explain how you would implement a binary search tree (BST) in Java?\n\n**Candidate:** Absolutely! To implement a binary search tree in Java, we start by defining two primary classes: a `Node` class that represents each individual element in the tree and a `BinarySearchTree` class that manages the overall tree structure and operations such as insertion, searching, and traversals.\n\n**Interviewer:** Great! Could you elaborate on the `Node` class?\n\n**Candidate:** Of course! The `Node` class serves as a blueprint for each node in the binary search tree. Each node contains three attributes:\n\n1. An integer `key`, which holds the value of the node.\n2. A `Node` reference `left`, which points to the left child node.\n3. A `Node` reference `right`, which points to the right child node.\n\nHere\u2019s how the `Node` class looks:\n\n```java\nclass Node {\n    int key;\n    Node left, right;\n\n    public Node(int item) {\n        key = item;\n        left = right = null; // Initially, children are null\n    }\n}\n```\n\n**Interviewer:** Nice! Now, how about the `BinarySearchTree` class? What does it contain?\n\n**Candidate:** The `BinarySearchTree` class encompasses the root of the tree and various methods to manipulate the BST. The key functionalities include inserting new keys, searching for keys, and traversing the tree.\n\nHere\u2019s a brief overview of the `BinarySearchTree` class:\n\n1. **Constructor:** It initializes the `root` of the BST to `null`.\n2. **Insert Method:** This method adds a new key to the BST.\n3. **Inorder Traversal Method:** This method prints the keys of the tree in sorted order.\n4. **Search Method:** This helps determine if a key exists in the tree.\n\nHere\u2019s the complete implementation of the `BinarySearchTree` class:\n\n```java\nclass BinarySearchTree {\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    // Insert a new key\n    void insert(int key) {\n        root = insertRec(root, key); // Start the recursive insertion\n    }\n\n    // Recursive function to insert a new key\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key); // Create a new node if we reach a null\n            return root;\n        }\n        if (key < root.key) {\n            root.left = insertRec(root.left, key); // Insert in the left subtree\n        } else if (key > root.key) {\n            root.right = insertRec(root.right, key); // Insert in the right subtree\n        }\n        return root; // Return unchanged node pointer\n    }\n\n    // Inorder traversal\n    void inorder() {\n        inorderRec(root); // Start the recursive inorder traversal\n    }\n\n    // Recursive function for inorder traversal\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left); // Visit the left subtree\n            System.out.print(root.key + \" \"); // Visit the node\n            inorderRec(root.right); // Visit the right subtree\n        }\n    }\n\n    // Search a key\n    boolean search(int key) {\n        return searchRec(root, key); // Start searching\n    }\n\n    // Recursive function to search a key\n    boolean searchRec(Node root, int key) {\n        if (root == null) return false; // Base case: key not found\n        if (root.key == key) return true; // Key found at root\n        if (key < root.key) {\n            return searchRec(root.left, key); // Search in the left subtree\n        } \n        return searchRec(root.right, key); // Search in the right subtree\n    }\n}\n```\n\n**Interviewer:** That\u2019s well explained! Could you share an example usage of this BST?\n\n**Candidate:** Sure! Here\u2019s how you could use this `BinarySearchTree` class:\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        BinarySearchTree bst = new BinarySearchTree();\n        \n        // Inserting values\n        bst.insert(50);\n        bst.insert(30);\n        bst.insert(20);\n        bst.insert(40);\n        bst.insert(70);\n        bst.insert(60);\n        bst.insert(80);\n        \n        // Inorder traversal\n        System.out.print(\"Inorder traversal: \");\n        bst.inorder(); // Should print: 20 30 40 50 60 70 80\n        \n        // Search for a value\n        int keyToSearch = 40;\n        System.out.println(\"\\nSearch for \" + keyToSearch + \": \" + bst.search(keyToSearch)); // Should return true\n    }\n}\n```\n\n**Interviewer:** Excellent! This implementation is clear and covers the essential operations of a binary search tree. Thank you for your explanation!\n\n---\n\nFeel free to adjust your understanding and presentation based on this structured approach for an interview setting!"
    }
]